<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: UART</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___u_a_r_t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Universal Asynchronous Receiver/Transmitter (UART) driver for XMC microcontroller family.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g.html">XMC_UART_CH_CONFIG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6fb5176e8780b26785415ec2406cb1a9"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_a_r_t.html#gae2a1514ed1a18d0d8ba09815dbb3201b">XMC_UART_CH_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6fb5176e8780b26785415ec2406cb1a9">XMC_UART_CH_STATUS_t</a></td></tr>
<tr class="separator:ga6fb5176e8780b26785415ec2406cb1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d2c007983f53c2965757f021c5fa69"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_a_r_t.html#gaf673b8181ec8cd10bc19d476716aaddf">XMC_UART_CH_STATUS_FLAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab1d2c007983f53c2965757f021c5fa69">XMC_UART_CH_STATUS_FLAG_t</a></td></tr>
<tr class="separator:gab1d2c007983f53c2965757f021c5fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c103e1b9722a590bbe623c51748667"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_a_r_t.html#gaa9afb0f8b31a3b17fa03151d45a7d8c4">XMC_CH_UART_EVENT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga22c103e1b9722a590bbe623c51748667">XMC_UART_CH_EVENT_t</a></td></tr>
<tr class="separator:ga22c103e1b9722a590bbe623c51748667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40cd243b6fece1ad1916e34e8cfa81a7"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_a_r_t.html#ga6a85843335216ade6405e2e59ef4ff55">XMC_UART_CH_INPUT_SAMPLING_FREQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga40cd243b6fece1ad1916e34e8cfa81a7">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a></td></tr>
<tr class="separator:ga40cd243b6fece1ad1916e34e8cfa81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df97a9e334389f5a04c906a36786b32"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_a_r_t.html#gac9e36820763b8000d15a22d9918ce9ff">XMC_UART_CH_INPUT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a></td></tr>
<tr class="separator:ga3df97a9e334389f5a04c906a36786b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6793eac2ce2c073072671ff50cfe3aac"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_a_r_t.html#ga23ecb891dfc73a973c1ad950ccd23141">XMC_UART_CH_INTERRUPT_NODE_POINTER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6793eac2ce2c073072671ff50cfe3aac">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a></td></tr>
<tr class="separator:ga6793eac2ce2c073072671ff50cfe3aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e915892a9aedf7c94b8c92d4536cd31"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g.html">XMC_UART_CH_CONFIG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7e915892a9aedf7c94b8c92d4536cd31">XMC_UART_CH_CONFIG_t</a></td></tr>
<tr class="separator:ga7e915892a9aedf7c94b8c92d4536cd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae2a1514ed1a18d0d8ba09815dbb3201b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gae2a1514ed1a18d0d8ba09815dbb3201b">XMC_UART_CH_STATUS</a> { <a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a>, 
<a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba146ec14a2e6f316f449c332a863289b0">XMC_UART_CH_STATUS_ERROR</a>, 
<a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba410817c31e098fd03c04f4d5ecb76ef1">XMC_UART_CH_STATUS_BUSY</a>
 }</td></tr>
<tr class="separator:gae2a1514ed1a18d0d8ba09815dbb3201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf673b8181ec8cd10bc19d476716aaddf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaf673b8181ec8cd10bc19d476716aaddf">XMC_UART_CH_STATUS_FLAG</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a> = USIC_CH_PSR_ASCMode_TXIDLE_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a> = USIC_CH_PSR_ASCMode_RXIDLE_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> = USIC_CH_PSR_ASCMode_SBD_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa1127a4bc2e8bca81c351cdc344245fd0">XMC_UART_CH_STATUS_FLAG_COLLISION_DETECTED</a> = USIC_CH_PSR_ASCMode_COL_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa147a2ad3b6ab6a1aacb07fa971eb1275">XMC_UART_CH_STATUS_FLAG_RECEIVER_NOISE_DETECTED</a> = USIC_CH_PSR_ASCMode_RNS_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfaf6d928be53c8c901a05872e3ef950bc7">XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_0</a> = USIC_CH_PSR_ASCMode_FER0_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa5733cca57c6cff9c79da3c824e644a72">XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_1</a> = USIC_CH_PSR_ASCMode_FER1_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa5abbfe2717ee3117550e329d90769863">XMC_UART_CH_STATUS_FLAG_RECEIVE_FRAME_FINISHED</a> = USIC_CH_PSR_ASCMode_RFF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfae8fe75675b2f99f20032577dd0ca4f7c">XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED</a> = USIC_CH_PSR_ASCMode_TFF_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa68079f24c35e5259c9984e39c602db45">XMC_UART_CH_STATUS_FLAG_TRANSFER_STATUS_BUSY</a> = USIC_CH_PSR_ASCMode_BUSY_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa81b11006a6b243c9f04f4a8a9f5c5735">XMC_UART_CH_STATUS_FLAG_RECEIVER_START_INDICATION</a> = USIC_CH_PSR_ASCMode_RSIF_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfadcd6021f9d2ab0764ae114b544a1244a">XMC_UART_CH_STATUS_FLAG_DATA_LOST_INDICATION</a> = USIC_CH_PSR_ASCMode_DLIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa4b78514f4ad98fead964ecf359c673ae">XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION</a> = USIC_CH_PSR_ASCMode_TSIF_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfaa8188ae95171fc9461c3c4905e41739b">XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION</a> = USIC_CH_PSR_ASCMode_TBIF_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa47f5b38bcab2bc0e1b009cffcca18855">XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION</a> = USIC_CH_PSR_ASCMode_RIF_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfaaac652362ebf22f1b23c1e2e4dd52cfa">XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION</a> = USIC_CH_PSR_ASCMode_AIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa5e66e98130f3a6f072c57295a1a779f7">XMC_UART_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION</a> = USIC_CH_PSR_ASCMode_BRGIF_Msk
<br />
 }</td></tr>
<tr class="separator:gaf673b8181ec8cd10bc19d476716aaddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9afb0f8b31a3b17fa03151d45a7d8c4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa9afb0f8b31a3b17fa03151d45a7d8c4">XMC_CH_UART_EVENT</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a> = (int32_t)(0x80000000U | USIC_CH_CCR_RSIEN_Msk), 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a> = (int32_t)(0x80000000U | USIC_CH_CCR_DLIEN_Msk), 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a> = (int32_t)(0x80000000U | USIC_CH_CCR_TSIEN_Msk), 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a> = (int32_t)(0x80000000U | USIC_CH_CCR_TBIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a3fec2fc1685b8db717c095a21053240a">XMC_UART_CH_EVENT_STANDARD_RECEIVE</a> = (int32_t)(0x80000000U | USIC_CH_CCR_RIEN_Msk), 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4ad640d6bca0daeeb45ac4023b1e4db5b4">XMC_UART_CH_EVENT_ALTERNATIVE_RECEIVE</a> = (int32_t)(0x80000000U | USIC_CH_CCR_AIEN_Msk), 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4ac9364f8566efee358ffc0491940122e2">XMC_UART_CH_EVENT_BAUD_RATE_GENERATOR</a> = (int32_t)(0x80000000U | USIC_CH_CCR_BRGIEN_Msk), 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a266352a130a03ea0a41565bc695ef146">XMC_UART_CH_EVENT_SYNCHRONIZATION_BREAK</a> = USIC_CH_PCR_ASCMode_SBIEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4acf263e5b91743a7e5d424d551a9f177b">XMC_UART_CH_EVENT_COLLISION</a> = USIC_CH_PCR_ASCMode_CDEN_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a9045609949ae1b88827a4ec8fd005b93">XMC_UART_CH_EVENT_RECEIVER_NOISE</a> = USIC_CH_PCR_ASCMode_RNIEN_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4aef5d7acb2f77f77405a56b2c04fbaba5">XMC_UART_CH_EVENT_FORMAT_ERROR</a> = USIC_CH_PCR_ASCMode_FEIEN_Msk, 
<a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a2ea7a5f9780633b9cb5702c1fc7296d2">XMC_UART_CH_EVENT_FRAME_FINISHED</a> = USIC_CH_PCR_ASCMode_FFIEN_Msk
<br />
 }</td></tr>
<tr class="separator:gaa9afb0f8b31a3b17fa03151d45a7d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a85843335216ade6405e2e59ef4ff55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6a85843335216ade6405e2e59ef4ff55">XMC_UART_CH_INPUT_SAMPLING_FREQ</a> { <a class="el" href="group___u_a_r_t.html#gga6a85843335216ade6405e2e59ef4ff55a916e6151ac686996fbef2b0c059d0527">XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH</a> = XMC_USIC_CH_INPUT_SAMPLING_FREQ_FPERIPH, 
<a class="el" href="group___u_a_r_t.html#gga6a85843335216ade6405e2e59ef4ff55ac1ae8f6ca1096c61ca0619dae0a18b92">XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER</a> = XMC_USIC_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER
 }</td></tr>
<tr class="separator:ga6a85843335216ade6405e2e59ef4ff55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e36820763b8000d15a22d9918ce9ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac9e36820763b8000d15a22d9918ce9ff">XMC_UART_CH_INPUT</a> { <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> = 0UL
 }</td></tr>
<tr class="separator:gac9e36820763b8000d15a22d9918ce9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ecb891dfc73a973c1ad950ccd23141"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga23ecb891dfc73a973c1ad950ccd23141">XMC_UART_CH_INTERRUPT_NODE_POINTER</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141a0069cc6489d3bf33490bf4cc95e998d4">XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a> = XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT, 
<a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141a59a31b003753d05ac1b5d5067751121e">XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> = XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER, 
<a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141a668bf0b677803516a7815b85cc98880d">XMC_UART_CH_INTERRUPT_NODE_POINTER_RECEIVE</a> = XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIVE, 
<a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141aa2617445b7d8d4c1b05dda8e02c1e431">XMC_UART_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE</a> = XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141ad86f5c91df1f3e5713ed174d1371a3f5">XMC_UART_CH_INTERRUPT_NODE_POINTER_PROTOCOL</a> = XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL
<br />
 }</td></tr>
<tr class="separator:ga23ecb891dfc73a973c1ad950ccd23141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga719ad21f9ccaf9585dd0b473b4daef7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7e915892a9aedf7c94b8c92d4536cd31">XMC_UART_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga719ad21f9ccaf9585dd0b473b4daef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b28640516b5abd6946861b8e069dc5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga65b28640516b5abd6946861b8e069dc5">XMC_UART_CH_Start</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga65b28640516b5abd6946861b8e069dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083e4d7b2be613994d61ebc9841f7ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#ga6fb5176e8780b26785415ec2406cb1a9">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga083e4d7b2be613994d61ebc9841f7ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f757d62a86fc8944cf7188137490b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#ga6fb5176e8780b26785415ec2406cb1a9">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0f757d62a86fc8944cf7188137490b62">XMC_UART_CH_SetBaudrate</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, uint32_t rate, uint32_t oversampling)</td></tr>
<tr class="separator:ga0f757d62a86fc8944cf7188137490b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9b41f5d74a0dde43d9b19166ffa7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint16_t data)</td></tr>
<tr class="separator:ga3a9b41f5d74a0dde43d9b19166ffa7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578c15fc0df2e8ea7a265c92c0a26536"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga578c15fc0df2e8ea7a265c92c0a26536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6f5a7ef41affa10c0190b50d90b2f68"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab6f5a7ef41affa10c0190b50d90b2f68">XMC_UART_CH_SetWordLength</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:gab6f5a7ef41affa10c0190b50d90b2f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9c799602a222b33bdca80aab23e073"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2c9c799602a222b33bdca80aab23e073">XMC_UART_CH_SetFrameLength</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:ga2c9c799602a222b33bdca80aab23e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf511dd60e7f23bc40bad0207ff9bd266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:gaf511dd60e7f23bc40bad0207ff9bd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87743034df2fe747615ce39a6b870a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga87743034df2fe747615ce39a6b870a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78efe9d95ee8f625db1324caaba9306c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga78efe9d95ee8f625db1324caaba9306c">XMC_UART_CH_SetInterruptNodePointer</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:ga78efe9d95ee8f625db1324caaba9306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fc1ad8d89020683ed39cdb546bacdd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga93fc1ad8d89020683ed39cdb546bacdd">XMC_UART_CH_SelectInterruptNodePointer</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga6793eac2ce2c073072671ff50cfe3aac">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:ga93fc1ad8d89020683ed39cdb546bacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d91c6f6e2be55f5c28be32435bbaad1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1d91c6f6e2be55f5c28be32435bbaad1">XMC_UART_CH_TriggerServiceRequest</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga1d91c6f6e2be55f5c28be32435bbaad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6374dc527b7a69200f266c715badec8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaf6374dc527b7a69200f266c715badec8">XMC_UART_CH_GetStatusFlag</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaf6374dc527b7a69200f266c715badec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36271f8ffec2a2c1b077ec2786f574c6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga36271f8ffec2a2c1b077ec2786f574c6">XMC_UART_CH_ClearStatusFlag</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint32_t flag)</td></tr>
<tr class="separator:ga36271f8ffec2a2c1b077ec2786f574c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f466fb1df22b9039936ed4e39f527a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gae5f466fb1df22b9039936ed4e39f527a">XMC_UART_CH_SetInputSource</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:gae5f466fb1df22b9039936ed4e39f527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd86123885067439df7e5585518d721a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacd86123885067439df7e5585518d721a">XMC_UART_CH_SetPulseLength</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint8_t pulse_length)</td></tr>
<tr class="separator:gacd86123885067439df7e5585518d721a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e2ea04eb37d4ee8fa657120cd71b06"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga80e2ea04eb37d4ee8fa657120cd71b06">XMC_UART_CH_SetSamplePoint</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const uint32_t sample_point)</td></tr>
<tr class="separator:ga80e2ea04eb37d4ee8fa657120cd71b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e655a939632f39559929dd3fb0116e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga43e655a939632f39559929dd3fb0116e">XMC_UART_CH_EnableInputInversion</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga43e655a939632f39559929dd3fb0116e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5014b70adad4aecdd405be1f33adb2e4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga5014b70adad4aecdd405be1f33adb2e4">XMC_UART_CH_DisableInputInversion</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga5014b70adad4aecdd405be1f33adb2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5445ff123683671c518fe9af75e3494b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga5445ff123683671c518fe9af75e3494b">XMC_UART_CH_EnableInputDigitalFilter</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga5445ff123683671c518fe9af75e3494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503313c71cb5117214e0e110e78c429a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga503313c71cb5117214e0e110e78c429a">XMC_UART_CH_DisableInputDigitalFilter</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga503313c71cb5117214e0e110e78c429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f3fba8eac14d0f2e087b5eae995ae9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga58f3fba8eac14d0f2e087b5eae995ae9">XMC_UART_CH_EnableInputSync</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga58f3fba8eac14d0f2e087b5eae995ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b523233580be7cc507363f1177e9e7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga89b523233580be7cc507363f1177e9e7">XMC_UART_CH_DisableInputSync</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga89b523233580be7cc507363f1177e9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24cc1247f2de6f4381c041e3b84db52"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gae24cc1247f2de6f4381c041e3b84db52">XMC_UART_CH_SetInputSamplingFreq</a> (<a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a> input, const <a class="el" href="group___u_a_r_t.html#ga40cd243b6fece1ad1916e34e8cfa81a7">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a> sampling_freq)</td></tr>
<tr class="separator:gae24cc1247f2de6f4381c041e3b84db52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Universal Asynchronous Receiver/Transmitter (UART) driver for XMC microcontroller family. </p>
<p>The UART driver uses Universal Serial Interface Channel(USIC) module to implement UART protocol. It provides APIs to configure USIC channel for UART communication. The driver enables the user in getting the status of UART protocol events, configuring interrupt service requests, protocol related parameter configuration etc.</p>
<p>UART driver features:</p><ol type="1">
<li>Configuration structure XMC_UART_CH_CONFIG_t and initialization function <a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a></li>
<li>Enumeration of events with their bit masks <a class="el" href="group___u_a_r_t.html#ga22c103e1b9722a590bbe623c51748667">XMC_UART_CH_EVENT_t</a>, <a class="el" href="group___u_a_r_t.html#gab1d2c007983f53c2965757f021c5fa69">XMC_UART_CH_STATUS_FLAG_t</a></li>
<li>Allows the selection of input source for the DX0 input stage using the API <a class="el" href="group___u_a_r_t.html#gae5f466fb1df22b9039936ed4e39f527a">XMC_UART_CH_SetInputSource()</a></li>
<li>Allows configuration of baudrate using <a class="el" href="group___u_a_r_t.html#ga0f757d62a86fc8944cf7188137490b62">XMC_UART_CH_SetBaudrate()</a> and configuration of data length using <a class="el" href="group___u_a_r_t.html#gab6f5a7ef41affa10c0190b50d90b2f68">XMC_UART_CH_SetWordLength()</a> and <a class="el" href="group___u_a_r_t.html#ga2c9c799602a222b33bdca80aab23e073">XMC_UART_CH_SetFrameLength()</a></li>
<li>Provides the status of UART protocol events, <a class="el" href="group___u_a_r_t.html#gaf6374dc527b7a69200f266c715badec8">XMC_UART_CH_GetStatusFlag()</a></li>
<li>Allows transmission of data using <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a> and gets received data using <a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData()</a> </li>
</ol>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga7e915892a9aedf7c94b8c92d4536cd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e915892a9aedf7c94b8c92d4536cd31">&#9670;&nbsp;</a></span>XMC_UART_CH_CONFIG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g.html">XMC_UART_CH_CONFIG</a> <a class="el" href="group___u_a_r_t.html#ga7e915892a9aedf7c94b8c92d4536cd31">XMC_UART_CH_CONFIG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART initialization structure </p>

</div>
</div>
<a id="ga22c103e1b9722a590bbe623c51748667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22c103e1b9722a590bbe623c51748667">&#9670;&nbsp;</a></span>XMC_UART_CH_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_a_r_t.html#gaa9afb0f8b31a3b17fa03151d45a7d8c4">XMC_CH_UART_EVENT</a> <a class="el" href="group___u_a_r_t.html#ga22c103e1b9722a590bbe623c51748667">XMC_UART_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART configuration events. The enums can be used for configuring events using the CCR register. </p>

</div>
</div>
<a id="ga40cd243b6fece1ad1916e34e8cfa81a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40cd243b6fece1ad1916e34e8cfa81a7">&#9670;&nbsp;</a></span>XMC_UART_CH_INPUT_SAMPLING_FREQ_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_a_r_t.html#ga6a85843335216ade6405e2e59ef4ff55">XMC_UART_CH_INPUT_SAMPLING_FREQ</a> <a class="el" href="group___u_a_r_t.html#ga40cd243b6fece1ad1916e34e8cfa81a7">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART Input sampling frequency options </p>

</div>
</div>
<a id="ga3df97a9e334389f5a04c906a36786b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3df97a9e334389f5a04c906a36786b32">&#9670;&nbsp;</a></span>XMC_UART_CH_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_a_r_t.html#gac9e36820763b8000d15a22d9918ce9ff">XMC_UART_CH_INPUT</a> <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART input stages </p>

</div>
</div>
<a id="ga6793eac2ce2c073072671ff50cfe3aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6793eac2ce2c073072671ff50cfe3aac">&#9670;&nbsp;</a></span>XMC_UART_CH_INTERRUPT_NODE_POINTER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_a_r_t.html#ga23ecb891dfc73a973c1ad950ccd23141">XMC_UART_CH_INTERRUPT_NODE_POINTER</a> <a class="el" href="group___u_a_r_t.html#ga6793eac2ce2c073072671ff50cfe3aac">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART channel interrupt node pointers </p>

</div>
</div>
<a id="gab1d2c007983f53c2965757f021c5fa69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d2c007983f53c2965757f021c5fa69">&#9670;&nbsp;</a></span>XMC_UART_CH_STATUS_FLAG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_a_r_t.html#gaf673b8181ec8cd10bc19d476716aaddf">XMC_UART_CH_STATUS_FLAG</a> <a class="el" href="group___u_a_r_t.html#gab1d2c007983f53c2965757f021c5fa69">XMC_UART_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART portocol status. The enum values can be used for getting the status of UART channel. </p>

</div>
</div>
<a id="ga6fb5176e8780b26785415ec2406cb1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb5176e8780b26785415ec2406cb1a9">&#9670;&nbsp;</a></span>XMC_UART_CH_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_a_r_t.html#gae2a1514ed1a18d0d8ba09815dbb3201b">XMC_UART_CH_STATUS</a> <a class="el" href="group___u_a_r_t.html#ga6fb5176e8780b26785415ec2406cb1a9">XMC_UART_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver status </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa9afb0f8b31a3b17fa03151d45a7d8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9afb0f8b31a3b17fa03151d45a7d8c4">&#9670;&nbsp;</a></span>XMC_CH_UART_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gaa9afb0f8b31a3b17fa03151d45a7d8c4">XMC_CH_UART_EVENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART configuration events. The enums can be used for configuring events using the CCR register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4addd2af8f6f565002a1b4ea856b7bbcee"></a>XMC_UART_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc"><p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4a6e76badf4b36a6fa694cd7c4c0d873b9"></a>XMC_UART_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc"><p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4af28054e5044087c68da450015df6771f"></a>XMC_UART_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4a26b35a7f887b79474fa97856749f182b"></a>XMC_UART_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4a3fec2fc1685b8db717c095a21053240a"></a>XMC_UART_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc"><p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4ad640d6bca0daeeb45ac4023b1e4db5b4"></a>XMC_UART_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc"><p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4ac9364f8566efee358ffc0491940122e2"></a>XMC_UART_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc"><p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4a266352a130a03ea0a41565bc695ef146"></a>XMC_UART_CH_EVENT_SYNCHRONIZATION_BREAK&#160;</td><td class="fielddoc"><p>Event synchronization break </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4acf263e5b91743a7e5d424d551a9f177b"></a>XMC_UART_CH_EVENT_COLLISION&#160;</td><td class="fielddoc"><p>Event collision </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4a9045609949ae1b88827a4ec8fd005b93"></a>XMC_UART_CH_EVENT_RECEIVER_NOISE&#160;</td><td class="fielddoc"><p>Event receiver noise </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4aef5d7acb2f77f77405a56b2c04fbaba5"></a>XMC_UART_CH_EVENT_FORMAT_ERROR&#160;</td><td class="fielddoc"><p>Event format error </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9afb0f8b31a3b17fa03151d45a7d8c4a2ea7a5f9780633b9cb5702c1fc7296d2"></a>XMC_UART_CH_EVENT_FRAME_FINISHED&#160;</td><td class="fielddoc"><p>Event frame finished </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00148">148</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gac9e36820763b8000d15a22d9918ce9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e36820763b8000d15a22d9918ce9ff">&#9670;&nbsp;</a></span>XMC_UART_CH_INPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gac9e36820763b8000d15a22d9918ce9ff">XMC_UART_CH_INPUT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART input stages </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d"></a>XMC_UART_CH_INPUT_RXD&#160;</td><td class="fielddoc"><p>UART input stage DX0 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00177">177</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga6a85843335216ade6405e2e59ef4ff55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a85843335216ade6405e2e59ef4ff55">&#9670;&nbsp;</a></span>XMC_UART_CH_INPUT_SAMPLING_FREQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga6a85843335216ade6405e2e59ef4ff55">XMC_UART_CH_INPUT_SAMPLING_FREQ</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART Input sampling frequency options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6a85843335216ade6405e2e59ef4ff55a916e6151ac686996fbef2b0c059d0527"></a>XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH&#160;</td><td class="fielddoc"><p>Sampling frequency input fperiph </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6a85843335216ade6405e2e59ef4ff55ac1ae8f6ca1096c61ca0619dae0a18b92"></a>XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER&#160;</td><td class="fielddoc"><p>Sampling frequency input fractional divider </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00168">168</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga23ecb891dfc73a973c1ad950ccd23141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ecb891dfc73a973c1ad950ccd23141">&#9670;&nbsp;</a></span>XMC_UART_CH_INTERRUPT_NODE_POINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga23ecb891dfc73a973c1ad950ccd23141">XMC_UART_CH_INTERRUPT_NODE_POINTER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART channel interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga23ecb891dfc73a973c1ad950ccd23141a0069cc6489d3bf33490bf4cc95e998d4"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga23ecb891dfc73a973c1ad950ccd23141a59a31b003753d05ac1b5d5067751121e"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga23ecb891dfc73a973c1ad950ccd23141a668bf0b677803516a7815b85cc98880d"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga23ecb891dfc73a973c1ad950ccd23141aa2617445b7d8d4c1b05dda8e02c1e431"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga23ecb891dfc73a973c1ad950ccd23141ad86f5c91df1f3e5713ed174d1371a3f5"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc"><p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00191">191</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gae2a1514ed1a18d0d8ba09815dbb3201b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a1514ed1a18d0d8ba09815dbb3201b">&#9670;&nbsp;</a></span>XMC_UART_CH_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gae2a1514ed1a18d0d8ba09815dbb3201b">XMC_UART_CH_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae2a1514ed1a18d0d8ba09815dbb3201ba1d4d4ea36dc6c0ceb6599efed42f0559"></a>XMC_UART_CH_STATUS_OK&#160;</td><td class="fielddoc"><p>UART driver status : OK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae2a1514ed1a18d0d8ba09815dbb3201ba146ec14a2e6f316f449c332a863289b0"></a>XMC_UART_CH_STATUS_ERROR&#160;</td><td class="fielddoc"><p>UART driver status : ERROR </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae2a1514ed1a18d0d8ba09815dbb3201ba410817c31e098fd03c04f4d5ecb76ef1"></a>XMC_UART_CH_STATUS_BUSY&#160;</td><td class="fielddoc"><p>UART driver status : BUSY </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00113">113</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gaf673b8181ec8cd10bc19d476716aaddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf673b8181ec8cd10bc19d476716aaddf">&#9670;&nbsp;</a></span>XMC_UART_CH_STATUS_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gaf673b8181ec8cd10bc19d476716aaddf">XMC_UART_CH_STATUS_FLAG</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART portocol status. The enum values can be used for getting the status of UART channel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa8838558f1c949dfdfa117908e21d7058"></a>XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit IDLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa02d60fc761d9eee4c4d1c525f2429a5c"></a>XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE&#160;</td><td class="fielddoc"><p>UART Protocol Status receive IDLE </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfaeaf9ee65696e36e06e012e0e3e5b5855"></a>XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED&#160;</td><td class="fielddoc"><p>UART Protocol Status synchronization break detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa1127a4bc2e8bca81c351cdc344245fd0"></a>XMC_UART_CH_STATUS_FLAG_COLLISION_DETECTED&#160;</td><td class="fielddoc"><p>UART Protocol Status collision detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa147a2ad3b6ab6a1aacb07fa971eb1275"></a>XMC_UART_CH_STATUS_FLAG_RECEIVER_NOISE_DETECTED&#160;</td><td class="fielddoc"><p>UART Protocol Status receiver noise detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfaf6d928be53c8c901a05872e3ef950bc7"></a>XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_0&#160;</td><td class="fielddoc"><p>UART Protocol Status format error in stop bit 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa5733cca57c6cff9c79da3c824e644a72"></a>XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_1&#160;</td><td class="fielddoc"><p>UART Protocol Status format error in stop bit 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa5abbfe2717ee3117550e329d90769863"></a>XMC_UART_CH_STATUS_FLAG_RECEIVE_FRAME_FINISHED&#160;</td><td class="fielddoc"><p>UART Protocol Status receive frame finished </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfae8fe75675b2f99f20032577dd0ca4f7c"></a>XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit frame finished </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa68079f24c35e5259c9984e39c602db45"></a>XMC_UART_CH_STATUS_FLAG_TRANSFER_STATUS_BUSY&#160;</td><td class="fielddoc"><p>UART Protocol Status transfer status busy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa81b11006a6b243c9f04f4a8a9f5c5735"></a>XMC_UART_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status receive start indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfadcd6021f9d2ab0764ae114b544a1244a"></a>XMC_UART_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status data lost indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa4b78514f4ad98fead964ecf359c673ae"></a>XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit shift indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfaa8188ae95171fc9461c3c4905e41739b"></a>XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit buffer indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa47f5b38bcab2bc0e1b009cffcca18855"></a>XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status receive indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfaaac652362ebf22f1b23c1e2e4dd52cfa"></a>XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status alternative receive indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf673b8181ec8cd10bc19d476716aaddfa5e66e98130f3a6f072c57295a1a779f7"></a>XMC_UART_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status baudrate generator indication flag </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00124">124</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga36271f8ffec2a2c1b077ec2786f574c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36271f8ffec2a2c1b077ec2786f574c6">&#9670;&nbsp;</a></span>XMC_UART_CH_ClearStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">flag</td><td>UART events to be cleared. <br  />
 <b>Range:</b> Use <a class="el" href="group___u_a_r_t.html#gab1d2c007983f53c2965757f021c5fa69">XMC_UART_CH_STATUS_FLAG_t</a> enumerations for event bitmasks. <a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the status of UART channel events.<br  />
<br  />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_UART_CH_STATUS_FLAG_t enumerates multiple event bitmasks. These enumerations can be used as input to the API. Events are cleared by setting the bitmask to the PSCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent()</a>, <a class="el" href="group___u_a_r_t.html#gaf6374dc527b7a69200f266c715badec8">XMC_UART_CH_GetStatusFlag()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00547">547</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga87743034df2fe747615ce39a6b870a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87743034df2fe747615ce39a6b870a0c">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Bitmask of events to disable. Use the type <a class="el" href="group___u_a_r_t.html#ga22c103e1b9722a590bbe623c51748667">XMC_UART_CH_EVENT_t</a> for naming events.<br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a>, <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the interrupt events by clearing the bits in CCR register.<br  />
<br  />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_UART_CH_EVENT_FLAG_t enumerates multiple event bitmasks. These enumerations can be used as input to the API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga36271f8ffec2a2c1b077ec2786f574c6">XMC_UART_CH_ClearStatusFlag()</a>, <a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00223">223</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="ga503313c71cb5117214e0e110e78c429a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503313c71cb5117214e0e110e78c429a">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableInputDigitalFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_DisableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the digital filter for UART input stage.<br  />
<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga5445ff123683671c518fe9af75e3494b">XMC_UART_CH_EnableInputDigitalFilter()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00690">690</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga5014b70adad4aecdd405be1f33adb2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5014b70adad4aecdd405be1f33adb2e4">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableInputInversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables input inversion for UART input data signal.<br  />
<br  />
Resets the input data polarity for the UART input data signal. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga43e655a939632f39559929dd3fb0116e">XMC_UART_CH_EnableInputInversion()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00654">654</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga89b523233580be7cc507363f1177e9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b523233580be7cc507363f1177e9e7">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableInputSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_DisableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables synchronous input for the UART input stage.<br  />
<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga58f3fba8eac14d0f2e087b5eae995ae9">XMC_UART_CH_EnableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#ga5445ff123683671c518fe9af75e3494b">XMC_UART_CH_EnableInputDigitalFilter()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00725">725</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gaf511dd60e7f23bc40bad0207ff9bd266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf511dd60e7f23bc40bad0207ff9bd266">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Event bitmasks to enable. Use the type <a class="el" href="group___u_a_r_t.html#ga22c103e1b9722a590bbe623c51748667">XMC_UART_CH_EVENT_t</a> for naming events. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a>, <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#ggaa9afb0f8b31a3b17fa03151d45a7d8c4a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables interrupt events for UART communication.<br  />
<br  />
Multiple events can be combined using the bitwise OR operation and configured in one function call. <a class="el" href="group___u_a_r_t.html#ga22c103e1b9722a590bbe623c51748667">XMC_UART_CH_EVENT_t</a> enumerates multiple event bitmasks. These enumerations can be used as input to the API. Events are configured by setting bits in the CCR register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent()</a>, <a class="el" href="group___u_a_r_t.html#ga78efe9d95ee8f625db1324caaba9306c">XMC_UART_CH_SetInterruptNodePointer()</a>, <a class="el" href="group___u_a_r_t.html#gaf6374dc527b7a69200f266c715badec8">XMC_UART_CH_GetStatusFlag()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00209">209</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="ga5445ff123683671c518fe9af75e3494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5445ff123683671c518fe9af75e3494b">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableInputDigitalFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_EnableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the digital filter for UART input stage.<br  />
<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga503313c71cb5117214e0e110e78c429a">XMC_UART_CH_DisableInputDigitalFilter()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00672">672</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga43e655a939632f39559929dd3fb0116e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43e655a939632f39559929dd3fb0116e">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableInputInversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables input inversion for UART input data signal.<br  />
<br  />
Polarity of the input source can be changed to provide inverted data input. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga5014b70adad4aecdd405be1f33adb2e4">XMC_UART_CH_DisableInputInversion()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00635">635</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga58f3fba8eac14d0f2e087b5eae995ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f3fba8eac14d0f2e087b5eae995ae9">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableInputSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_EnableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables synchronous input for the UART input stage.<br  />
<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga89b523233580be7cc507363f1177e9e7">XMC_UART_CH_DisableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#ga5445ff123683671c518fe9af75e3494b">XMC_UART_CH_EnableInputDigitalFilter()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00707">707</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga578c15fc0df2e8ea7a265c92c0a26536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga578c15fc0df2e8ea7a265c92c0a26536">&#9670;&nbsp;</a></span>XMC_UART_CH_GetReceivedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_UART_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Received data over UART communication channel. </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides one word of data received over UART communication channel.<br  />
<br  />
Based on the channel configuration, data is either read from the receive FIFO or RBUF register. Before returning the value, there is no check for data validity. User should check the appropriate data receive flags(standard receive/alternative receive/FIFO standard receive/FIFO alternative receive) before executing the API. Reading from an empty receive FIFO can generate a receive error event.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf6374dc527b7a69200f266c715badec8">XMC_UART_CH_GetStatusFlag()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00177">177</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="gaf6374dc527b7a69200f266c715badec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6374dc527b7a69200f266c715badec8">&#9670;&nbsp;</a></span>XMC_UART_CH_GetStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t XMC_UART_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of UART channel events. <br  />
 <b>Range:</b> Use <a class="el" href="group___u_a_r_t.html#gab1d2c007983f53c2965757f021c5fa69">XMC_UART_CH_STATUS_FLAG_t</a> enumerations for event bitmasks. <a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#ggaf673b8181ec8cd10bc19d476716aaddfaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> etc.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of UART channel events.<br  />
<br  />
Status provided by the API represents the status of multiple events at their bit positions. The bitmasks can be obtained using the enumeration XMC_UART_CH_STATUS_FLAG_t. Event status is obtained by reading the register PSR_ASCMode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a>, <a class="el" href="group___u_a_r_t.html#ga36271f8ffec2a2c1b077ec2786f574c6">XMC_UART_CH_ClearStatusFlag()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00524">524</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga719ad21f9ccaf9585dd0b473b4daef7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga719ad21f9ccaf9585dd0b473b4daef7e">&#9670;&nbsp;</a></span>XMC_UART_CH_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7e915892a9aedf7c94b8c92d4536cd31">XMC_UART_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">config</td><td>Constant pointer to UART configuration structure of type <a class="el" href="group___u_a_r_t.html#ga7e915892a9aedf7c94b8c92d4536cd31">XMC_UART_CH_CONFIG_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status of initializing the USIC channel for UART protocol.<br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if initialization is successful.<br  />
 <a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba146ec14a2e6f316f449c332a863289b0">XMC_UART_CH_STATUS_ERROR</a> if configuration of baudrate failed.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the USIC channel for UART protocol.<br  />
<br  />
During the initialization, USIC channel is enabled, baudrate is configured with the defined oversampling value in the intialization structure. If the oversampling value is set to 0 in the structure, the default oversampling of 16 is considered. Sampling point for each symbol is configured at the half of sampling period. Symbol value is decided by the majority decision among 3 samples. Word length is configured with the number of data bits. If the value of <em>frame_length</em> is 0, then USIC channel frame length is set to the same value as word length. If <em>frame_length</em> is greater than 0, it is set as the USIC channel frame length. Parity mode is set to the value configured for <em>parity_mode</em>. The USIC channel should be set to UART mode by calling the <a class="el" href="group___u_a_r_t.html#ga65b28640516b5abd6946861b8e069dc5">XMC_UART_CH_Start()</a> API after the initialization.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga65b28640516b5abd6946861b8e069dc5">XMC_UART_CH_Start()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00086">86</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="ga93fc1ad8d89020683ed39cdb546bacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fc1ad8d89020683ed39cdb546bacdd">&#9670;&nbsp;</a></span>XMC_UART_CH_SelectInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SelectInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga6793eac2ce2c073072671ff50cfe3aac">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141a0069cc6489d3bf33490bf4cc95e998d4">XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#gga23ecb891dfc73a973c1ad950ccd23141a59a31b003753d05ac1b5d5067751121e">XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br  />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br  />
<br  />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br  />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00479">479</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga0f757d62a86fc8944cf7188137490b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f757d62a86fc8944cf7188137490b62">&#9670;&nbsp;</a></span>XMC_UART_CH_SetBaudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#ga6fb5176e8780b26785415ec2406cb1a9">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">rate</td><td>Desired baudrate. <br  />
 <b>Range:</b> minimum value = 100, maximum value depends on the peripheral clock frequency<br  />
 and <em>oversampling</em>. Maximum baudrate can be derived using the formula: (fperiph * 1023)/(1024 * oversampling) </td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data.<br  />
 This can be related to the number of samples for each logic state of the data signal.<br  />
 <b>Range:</b> 4 to 32. Value should be chosen based on the protocol used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status indicating the baudrate configuration.<br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggac2093935c82fd30f2de4c135d00fb201a7f5eeda6309c7b3a3e8f08380ed47e3c">XMC_USIC_CH_STATUS_OK</a> if baudrate is successfully configured, <a class="el" href="group___u_s_i_c.html#ggac2093935c82fd30f2de4c135d00fb201af9cf48d10eb977902d20eeaed491bcf0">XMC_USIC_CH_STATUS_ERROR</a> if desired baudrate or oversampling is invalid.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second.<br  />
<br  />
Derives the values of <em>STEP</em> and PDIV to arrive at the optimum realistic speed possible. <em>oversampling</em> is the number of samples to be taken for each symbol of UART protocol. Default <em>oversampling</em> of 16 is considered if the input <em>oversampling</em> is less than 4. It is recommended to keep a minimum oversampling of 4 for UART.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00139">139</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="ga2c9c799602a222b33bdca80aab23e073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9c799602a222b33bdca80aab23e073">&#9670;&nbsp;</a></span>XMC_UART_CH_SetFrameLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of data bits in each UART frame. <br  />
 <b>Range:</b> minimum= 1, maximum= 64. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the number of data bits for UART communication.<br  />
<br  />
The frame length is configured by setting the input value to <em>SCTR</em> register. The value of <em>frame_length</em> will be decremented by 1, before setting it to the register. Frame length should not be set to 64 for UART communication.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gab6f5a7ef41affa10c0190b50d90b2f68">XMC_UART_CH_SetWordLength()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00393">393</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gae24cc1247f2de6f4381c041e3b84db52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24cc1247f2de6f4381c041e3b84db52">&#9670;&nbsp;</a></span>XMC_UART_CH_SetInputSamplingFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetInputSamplingFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga40cd243b6fece1ad1916e34e8cfa81a7">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a>&#160;</td>
          <td class="paramname"><em>sampling_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
    <tr><td class="paramname">sampling_freq</td><td>Input sampling frequency. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga6a85843335216ade6405e2e59ef4ff55a916e6151ac686996fbef2b0c059d0527">XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH</a>, <a class="el" href="group___u_a_r_t.html#gga6a85843335216ade6405e2e59ef4ff55ac1ae8f6ca1096c61ca0619dae0a18b92">XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the sampling frequency for the UART input stage.<br  />
<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga58f3fba8eac14d0f2e087b5eae995ae9">XMC_UART_CH_EnableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#ga5445ff123683671c518fe9af75e3494b">XMC_UART_CH_EnableInputDigitalFilter()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00745">745</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gae5f466fb1df22b9039936ed4e39f527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5f466fb1df22b9039936ed4e39f527a">&#9670;&nbsp;</a></span>XMC_UART_CH_SetInputSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga3df97a9e334389f5a04c906a36786b32">XMC_UART_CH_INPUT_t</a>. <br  />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggac9e36820763b8000d15a22d9918ce9ffacaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. The table provided below maps the decimal value with the input source. <table class="doxtable">
<tr>
<td>0</td><td>DXnA</td></tr>
<tr>
<td>1</td><td>DXnB</td></tr>
<tr>
<td>2</td><td>DXnC</td></tr>
<tr>
<td>3</td><td>DXnD </td></tr>
<tr>
<td>4</td><td>DXnE</td></tr>
<tr>
<td>5</td><td>DXnF</td></tr>
<tr>
<td>6</td><td>DXnG</td></tr>
<tr>
<td>7</td><td>Always 1 </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets input soource for the UART communication.<br  />
<br  />
It is used for configuring the input stage for data reception. Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for the input stages DX0, DX3 and DX5.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga43e655a939632f39559929dd3fb0116e">XMC_UART_CH_EnableInputInversion()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00573">573</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga78efe9d95ee8f625db1324caaba9306c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78efe9d95ee8f625db1324caaba9306c">&#9670;&nbsp;</a></span>XMC_UART_CH_SetInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number for generating protocol interrupts.<br  />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for UART channel protocol events.<br  />
<br  />
For all the protocol events enlisted in the enumeration XMC_UART_CH_EVENT_t, one common interrupt gets generated. The service request connects the interrupt node to the UART protocol events. Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00453">453</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gacd86123885067439df7e5585518d721a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd86123885067439df7e5585518d721a">&#9670;&nbsp;</a></span>XMC_UART_CH_SetPulseLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetPulseLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>pulse_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">pulse_length</td><td>Length of the zero pulse in number of time quanta. <br  />
 <b>Range:</b> 0 to 7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the length of zero pulse in number of time quanta. Value 0 indicates one time quanta.<br  />
<br  />
Maximum possible is 8 time quanta with the value configured as 7.<br  />
The value is set to PCR_ASCMode register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga43e655a939632f39559929dd3fb0116e">XMC_UART_CH_EnableInputInversion()</a>, <a class="el" href="group___u_a_r_t.html#ga80e2ea04eb37d4ee8fa657120cd71b06">XMC_UART_CH_SetSamplePoint()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00594">594</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga80e2ea04eb37d4ee8fa657120cd71b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e2ea04eb37d4ee8fa657120cd71b06">&#9670;&nbsp;</a></span>XMC_UART_CH_SetSamplePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetSamplePoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">sample_point</td><td>Sample point among the number of samples. <br  />
 <b>Range:</b> minimum= 0, maximum= <em>oversampling</em> (DCTQ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the sample point among the multiple samples for each UART symbol.<br  />
<br  />
The sample point is the one sample among number of samples set as oversampling. The value should be less than the oversampling value. <a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a> sets the sample point to the sample at the centre. For example if the oversampling is 16, then the sample point is set to 9. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga43e655a939632f39559929dd3fb0116e">XMC_UART_CH_EnableInputInversion()</a>, <a class="el" href="group___u_a_r_t.html#ga80e2ea04eb37d4ee8fa657120cd71b06">XMC_UART_CH_SetSamplePoint()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00615">615</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="gab6f5a7ef41affa10c0190b50d90b2f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6f5a7ef41affa10c0190b50d90b2f68">&#9670;&nbsp;</a></span>XMC_UART_CH_SetWordLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">word_length</td><td>Data word length. <br  />
 <b>Range:</b> minimum= 1, maximum= 16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the data word length in number of bits.<br  />
<br  />
Word length can range from 1 to 16. It indicates the number of data bits in a data word. The value of <em>word_length</em> will be decremented by 1 before setting the value to <em>SCTR</em> register. If the UART data bits is more than 16, then the frame length should be set to the actual number of bits and word length should be configured with the number of bits expected in each transaction. For example, if number of data bits for UART communication is 20 bits, then the frame length should be set as 20. Word length can be set based on the transmit and receive handling. If data is stored as 8bit array, then the word length can be set to 8. In this case, a full message of UART data should be transmitted/ received as 3 data words.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga2c9c799602a222b33bdca80aab23e073">XMC_UART_CH_SetFrameLength()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00372">372</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga65b28640516b5abd6946861b8e069dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65b28640516b5abd6946861b8e069dc5">&#9670;&nbsp;</a></span>XMC_UART_CH_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the USIC channel operation mode to UART mode.<br  />
<br  />
CCR register bitfield <em>Mode</em> is set to 2(UART mode). This API should be called after configuring the USIC channel. Transmission and reception can happen only when the UART mode is set. This is an inline function.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00266">266</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
<a id="ga083e4d7b2be613994d61ebc9841f7ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083e4d7b2be613994d61ebc9841f7ebd">&#9670;&nbsp;</a></span>XMC_UART_CH_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#ga6fb5176e8780b26785415ec2406cb1a9">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status to indicate if the communication channel is stopped successfully.<br  />
 <a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if the communication channel is stopped. <a class="el" href="group___u_a_r_t.html#ggae2a1514ed1a18d0d8ba09815dbb3201ba410817c31e098fd03c04f4d5ecb76ef1">XMC_UART_CH_STATUS_BUSY</a> if the communication channel is busy.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Stops the UART communication.<br  />
<br  />
CCR register bitfield <em>Mode</em> is reset. This disables the communication. Before starting the communication again, the channel has to be reconfigured.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00194">194</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="ga3a9b41f5d74a0dde43d9b19166ffa7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9b41f5d74a0dde43d9b19166ffa7c6">&#9670;&nbsp;</a></span>XMC_UART_CH_Transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted. <br  />
 <b>Range:</b> 16 bit unsigned data within the range 0 to 65535. Actual size of data transmitted depends on the configured number of bits for the UART protocol in the register SCTR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Transmits data over serial communication channel using UART protocol.<br  />
<br  />
Based on the channel configuration, data is either put to the transmit FIFO or to TBUF register. Before putting data to TBUF, the API waits for TBUF to finish shifting its contents to shift register. So user can continuously execute the API without checking for TBUF busy status. Based on the number of data bits configured, the lower significant bits will be extracted for transmission.</dd></dl>
<p>Note: When FIFO is not configured, the API waits for the TBUF to be available. This makes the execution a blocking call.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8c_source.html#l00155">155</a> of file <a class="el" href="xmc__uart_8c_source.html">xmc_uart.c</a>.</p>

</div>
</div>
<a id="ga1d91c6f6e2be55f5c28be32435bbaad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d91c6f6e2be55f5c28be32435bbaad1">&#9670;&nbsp;</a></span>XMC_UART_CH_TriggerServiceRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void XMC_UART_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="group___u_s_i_c.html#gab79a19dac84ff17c48b06cfa3b38ecc3">XMC_USIC_CH_t</a> <br  />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br  />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a UART interrupt service request.<br  />
<br  />
When the UART service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga93fc1ad8d89020683ed39cdb546bacdd">XMC_UART_CH_SelectInterruptNodePointer()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__uart_8h_source.html#l00502">502</a> of file <a class="el" href="xmc__uart_8h_source.html">xmc_uart.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
